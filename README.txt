Trabajo Practico 1 Algoritmos y Programacion 2
La gran pesca pokemon
Explicacion del trabajo:
El presente trabajo practico busca realizar una simulacion de una situacion en especifica. En esta hay un arrecife con pokemones y un acuario sin pokemones. Por un evento se quieren buscar ciertos pokemones que cumplan con caracteristicas especificas y si hay cantidad suficiente para que no represente un riesgo trasladarlos al acuario. Alli se debera poder saber que pokemones se encuentran en cada uno y obtener informacion de ambos lugares. Para esta simulacion, se poseen 7 funciones principales brindadas por las catedras con sus respectivas estructuras necesarias y se debe crear cualquier funcion o estructura extra necesaria. Para realizar la simulacion, se considera que se posee un archivo con los pokemones inicialmente en el arrecife y la forma de saber la situacion del arrecife y acuario se muestran en pantalla los pokemones que quedan en el arrecife tras cada movimiento. Al finalizar se cargan los pokemones que estan en el acuario en un archivo.

Analizando el flujo el flujo del programa, al iniciar la ejecucion y realizar las declaraciones de variables necesarias se obtendra la ruta al archivo de arrecife recibido por linea de comando. Tras esto, creara el arrecife y cargará los pokemones del archivo de texto en este. En caso de fallar la funcion y no poder crear un arrecife, se detiene la ejecucion del programa. Posteriormente se creará el acuario. Ya con ambos lugares creados, comienza el proceso de trasladar y censar.
El programa debera trasladar todos los pokemones que cumplan con las condiciones que se encuentren en la funcion de la cual se envia un puntero. La cantidad de pokemones a trasladar sera pedida al usuario asi el puede decidir la cantidad de pokemones que quiere que cumplan esa condicion en especifico. Al mismo tiempo que se va haciendo el traslado el programa ira achicando y agrandando los vectores de pokemones para que siempre tengan el tamaño de la cantidad de elementos que contienen. Para el traslado, primero se verificara que la cantidad de pokemones sea que cumplen la condicion del traslado sea suficiente. Si lo es comienza a trasladar. Para esto carga ese en el vector de pokemones del acuario y para la eliminacion del vector de pokemones del arrecife simplemente se intercambia la posicion con el ultimo del vector y se achica el tamaño de este (esto es posible ya que no es necesario tener un archivo ordenado).
Una vez con el traslado realizado, se procede a censar el arrecife mostrando por pantalla los pokemones que siguen estando en el arrecife.Este proceso de traslado y censado, se repetira hasta que se haya hecho con todas las condiciones planteadas en el programa en este caso 5.
Una vez terminados todos los traslados y el censado, se guardaran los datos de los pokemones que estan en el acuario en un archivo de texto "pokemones_acuario.txt" que se creara si no existe y si ya existe se sobreescribira. Finalizado esto, se liberará la memoria necesaria y se terminara la ejecucion del programa.

Explicacion comilacion y ejecucion:
La linea de compilación usada es la siguiente:
gcc *.c -Wall -Werror -Wconversion -std=c99 -o evento_pesca
Con esta con el *.c se dice que compile todos los archivos que encuentre que teminen en.c. Los flags -Wall, -Werror y -Wconversion. Estos se encargan de mostrar todos los errores y advertencias y considerarlos como errores, ademas de considerar los cambios de tipo de datos no declarados. Con el -o evento_pesca se dice que el ejecutable que se creara tendra ese nombre. Además si se quiere realizar un debugging se le debe agregar el flag -g.
Para la ejecicion se utilizará la siguiente linea de comando:
./evento_pesca arrecife.txt
Siendo la primera parte el nombre del ejecutable. Lo siguiente es el nombre del archivo que se utilizará con los pokemones del arrecife, en este caso "arrecife.txt"
Tambien se ejecutara con Vallgrind para evaluar si hay perdidas de memoria, para esto se utilizara la siguiente linea de comandos:
valgrind --leak-check=full --track-origins=yes --show-reachable=yes ./evento_pesca arrecife.txt
Con esto se puede saber si toda la memoria que se pidio con malloc o realloc. Con los flags indicara si hay perdidas, donde y si son alcansables o no. Luego se debe poner la misma linea que la de ejecucion, incluido el nombre del archivo de arrecife a utilizar.

Explique brevemente y de forma concisa los siguientes conceptos:
Punteros:
Un puntero es un tipo de dato de que almacena la direccion de memoria de otra variable. Son usados para poder hacer el codigo mas legible y eficiente. Gracias a estos es posible modificar una variable en otro ambito ya que se sabe donde esta esta ubicada. En este trabajo en particular se utiliza de forma notoria en el manejo de los pokemones. Al enviar un puntero al primer elemento del vector y la cantidad de elementos de este es posible acceder en cualquier parte del programa a cualquier campo de este vector y modificarlo o operar con este.
Aritmética de punteros;
La aritmetica de punteros, es lo que les da una gran parte de su poder a los punteros, ya que nos permite realizar operaciones basicas con ellos para allídesplazarnos o modificarlos. Estas operaciones son suma, resta, comparacion y asignacion. Por ejemplo en el trabajo practica debido a la aritmetica de punteros es que si yo quiero acceder al pokemon numero 3 de mi vector de pokemones lo puedo hacer simplemente poniendo *pokemon +=3. Esto facilita el manejo al no necesitar pasar un vector con sus maximos y manejar sus subindices.
Punteros a funciones:
Un puntero a funcion es poder generar una variable del tipo puntero que me apunte al inicio del codigo de una funcion pudiendo asi acceder a este desde otro ambito llamando al puntero. Esta sirve como se ve en el trabajo practico para poder dejarle luego al usuario o cliente generar esas funciones que el puede querer y yo necesito para otras operaciones sin el tener acceso a mi codigo. En el trabajo se ve muy claramente en el criterio de seleccion. Yo como programador le puedo dar la posibilidad al usuario (Misty) de crear sus funciones de seleccion sin ella acceder a mis librerias. Además yo no necesito luego modificar las librerias para estos cambios.
Malloc y Realloc:
La funcion malloc se encarga de reservar una determinada cantidad de memoria del heap y devolver un puntero al primer elementos de estos. El realloc, por otro lado, dado un puntero a una ubicacion de memoria reservada, va a modificar el tamaño de esta a la que se le diga. Esta nueva cantidad de memoria puede ser tanto mayor como menor. En caso de que se quiera una memoria mayor y en donde se encuentra el puntero recibido no entre esa capacidad de memoria a la que lo quiero ampliar buscara otro lugar. Esta mantendrá toda la informacion ya cargada alli sin modificarla. Al igual que el malloc devuelve la direcion de memoria del primer elemento. En caso de fallar, ambas funciones devolveran NULL. Su uso esta ligado a la memoria dinamica, en este trabajo, se usan ya que ermite tener vectores realmente dinamicos e ir modificando su tamño segun se necesite (es lo que se realiza con los vectores de pokemones).
Estas funciones poseen la siguiente sintaxis:
malloc(sizet tamaño), siendo tamaño el tamaño en bytes que se quiere reservar
realloc(void* puntero, sizet tamaño), siendo el primero el puntero al primer elemento de memoria reservada que se quiere modificar el tamaño y tamaño el tamaño en bytes que se desea que quede reservado.
